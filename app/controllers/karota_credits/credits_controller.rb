# frozen_string_literal: true
module KarotaCredits

  CREDIT_BALANCE_COL = 'credit_balance'
  MAX_CREDIT_BALANCE = 100
  BEGINNING = '2022-01-01'

  class CreditsController < ActionController::API

    ##
    # This API class is responsible for adding and gifting credits
    # to the users of the platform.
    # NOTE: RDoc convention is used for docstring design.
    #   Reference: https://stackoverflow.com/a/1681534
    before_action :authenticate_api_key

    def index
      head 200
    end

    ##
    # Authenticate the 'Api-Key' in the HTTP header.
    # The 'Api-Key' is generated in the admin panel.
    def authenticate_api_key
      raise Discourse::InvalidAccess unless request.headers["Api-Key"]
      @hashed_api_key = ApiKey.hash_key(request.headers["Api-Key"])
      api_key_record = ApiKey.find_by(key_hash: @hashed_api_key)
      raise Discourse::InvalidAccess unless api_key_record
    end

    ##
    # Returns the mean of the credit balance of all users in JSON format.
    def get_credits_mean
      credits_mean = UserCustomField.where(name: CREDIT_BALANCE_COL).average("value::float")
      render json: credits_mean
		end

    ##
    # Adds credit to the credit balance of all users.
    # This method is expecting an API parameter 'amount'.
    def add_credits
      params.require(:amount)
      amount = params[:amount]

      credits = UserCustomField.where(name: CREDIT_BALANCE_COL)
      credits.each do |credit|
        new_credit = calculate_new_credit_balance(credit[:value], amount)
        update_credit_balance(credit[:user_id], new_credit)
      end
    end

    ##
    # Calculate the new credit balance.
    # Params:
    # +credit+:: Current credit balance of the user.
    # +amount+:: Amount that will be added to the credit balance of the user.
    # Returns:
    # +new_credit+:: New credit balance of the user.
    def calculate_new_credit_balance(credit, amount)
      credit = credit.to_f
      amount = amount.to_f
      user_polarity = get_user_polarity
      new_credit = amount * (1 - user_polarity) + credit
      new_credit
    end

    ##
    # Return the user polarity, temporarily returns 0.
    def get_user_polarity
      0
    end

    ##
    # Updates the credit balance of users.
    # Params:
    # +user_id+:: Unique id of the user.
    # +new_credit+:: The new be credit balance of the user.
    # Returns:
    # SQL record from `user_custom_fields` table.
    def update_credit_balance(user_id, new_credit)
      UserCustomField
        .where(name: CREDIT_BALANCE_COL, user_id: user_id)
        .update_all(value: new_credit, updated_at: DateTime.now)
    end
    
    ##
    # Get the user ids of users that has credit balance.
    def get_user_ids_with_credits
      UserCustomField.select(:user_id).where(name: CREDIT_BALANCE_COL)
    end

    ##
    # Gift users with credit balance based on behavior
    # Algoritm
    # - Find users with credit balance
    # - Compute the gained rewards of each user
    # - Add the gained rewards to the credit balance of each user
    # API params:
    # +amount+:: Amount that will be used in the formula for calculating the reward. Required.
    # +date+:: Date that will be used for looking up the user's activity.
    def gift_rewards
      params.require(:amount)

      amount = params[:amount].to_f
      date = params[:date] ||= DateTime.now.strftime('%Y-%m-%d')

      ucf_credit_records = get_user_ids_with_credits
      ucf_credit_records.each do |record|
        reward = get_rewards(amount, record[:user_id], date)
        unless reward.nil?
          new_credit_balance = add_rewards_to_credits(record[:user_id], reward)
          update_credit_balance(record[:user_id], new_credit_balance)
        end
      end
    end

    ##
    # Calculate the gained reward of a user based on the user's behavior
    # and activity.
    # Params:
    # +amount+:: Generated by the API caller. Used in activity reward formula.
    # +user_id+:: Unique id of the user.
    # +date+:: Date lookup for user activity.
    # Returns:
    # +gained_reward+:: Credit amount the user will get.
    def get_rewards(amount, user_id, date)
      @created_posts = get_created_posts(user_id, date)
      return if @created_posts.empty?
      total_created_posts = @created_posts.count
      posts_polarization_vector = get_post_polarization_vector
      @post_polarization_score = calculate_post_polarity(posts_polarization_vector)
      @total_followers = get_new_followers(user_id)
      @total_likes_received = get_new_likes_received(user_id, date)
      gained_reward = (0.5 + amount) * (1 - @post_polarization_score) * total_created_posts * (@total_followers + @total_likes_received)
      gained_reward
    end

    ##
    # Returns id, user_id, like_count, created 
    # and updated at of posts, 'nil' if none.
    # Params:
    # +user_id+:: Unique id of the user.
    # +date+:: Date lookup for created posts. 
    # Returns:
    # +created_posts+:: SQL record of created post(s) of a user in a specific date.
    def get_created_posts(user_id, date)
      sql = <<~SQL
        SELECT id, user_id, like_count, created_at, updated_at from posts
        WHERE created_at::DATE = :created_at
        AND user_id = :user_id
      SQL
      created_posts = DB.query(sql, created_at: date, user_id: user_id)
      created_posts
    end

    ##
    # Calculate the mean of the post polarity vector.
    # Params:
    # +vector+:: Array of numerical values, expected values are total
    #   dislikes/toxic reaction of a post. 
    def calculate_post_polarity(vector)
      post_polarity_vector = vector.map { |x| x.abs }
      sum = post_polarity_vector.sum.to_f
      count = post_polarity_vector.count.to_f
      mean = sum / count
      mean
    end

    ##
    # Gets the toxic polarity of posts.
    # The data to use the polarity is the total count of 
    # dislike reactions of the post.
    # Returns:
    # +polarization_vector+:: Toxic/dislike emoji count vector.
    def get_post_polarization_vector
      post_ids = []
      polarization_vector = []
      @created_posts.each do |post|
        post_ids.push(post.id)
      end 

      sql = <<~SQL
        SELECT reaction_users_count from discourse_reactions_reactions
        WHERE post_id IN (:post_ids)
        AND reaction_value = '-1'
      SQL
      result = DB.query(sql, post_ids: post_ids)
      
      result.each do |record|
        polarization_vector.push(record.reaction_users_count)
      end
      polarization_vector
    end

    ##
    # Returns the new followers of the user.
    # Will temporarily returns 0 because follow is not
    # supported by default in Discourse.
    # Params:
    # +user_id+:: Unique id of the user.
    # Returns:
    # 0
    def get_new_followers(user_id)
      return 0
    end

    ##
    # Get the new gained likes of the user based on the number of likes
    # of created posts.
    # Params:
    # +user_id+:: Unique id of the user.
    # +date+:: Date lookup for new likes.
    # Returns:
    # +new_likes+:: Total gained likes the user received from their posts.
    def get_new_likes_received(user_id, date)
      today = date
      yesterday = date.to_date - 1.day
      sql_yesterday = <<~SQL
        SELECT SUM(like_count) total_likes from posts
        WHERE created_at BETWEEN :beginning AND  :yesterday
        AND user_id = :user_id
      SQL
      result_yesterday = DB.query(sql_yesterday, 
        beginning: BEGINNING, yesterday: yesterday, user_id: user_id)
      if result_yesterday[0].total_likes.nil?
        likes_since_yesterday = 0
      else
        likes_since_yesterday = result_yesterday[0].total_likes
      end

      sql_today = <<~SQL
        SELECT SUM(like_count) total_likes from posts
        WHERE created_at BETWEEN :beginning AND :today
        AND user_id = :user_id
      SQL
      result_today = DB.query(sql_today, beginning: BEGINNING, today: today, user_id: user_id)
      if result_today[0].total_likes.nil?
        likes_since_today = 0
      else
        likes_since_today = result_today[0].total_likes
      end
      
      new_likes = likes_since_today - likes_since_yesterday
      new_likes
    end

    ##
    # Calculate the new credit balance of the user based on
    # gained rewards.
    # Params:
    # +user_id+:: Unique id of the user.
    # +reward+:: Gained rewards based on user's activity.
    # Returns:
    # +new_credit_balance+:: New credit balance of the user.
    def add_rewards_to_credits(user_id, reward)
      result = UserCustomField.select(:value)
        .where(name: CREDIT_BALANCE_COL, user_id: user_id)
        .first
      current_credit_balance = result.value.to_f
      new_credit_balance = current_credit_balance + reward
      new_credit_balance = [
          (new_credit_balance - 1 + (1 - @post_polarization_score) * reward / 2 + 1), 
          MAX_CREDIT_BALANCE
        ].min
      new_credit_balance
    end
  end
end